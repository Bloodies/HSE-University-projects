{$asmmode intel}

// 28
// Задано N слов по M символов в каждом.
// Символы являются элементами двумерного массива типа char.
// Программа переставляет строки по алфавиту.
// Если совпадает первая буква, слова различаются по второй и т.д.

CONST
   N = 2; //строки
   M = 3; //символы
VAR
   mas: array [0..N, 0..M] of char;
   i,j: integer;
BEGIN
   mas[0,0] := 'a';
   mas[0,1] := 'a';
   mas[0,2] := 'a';
   mas[0,3] := 'd';
   mas[1,0] := 'd';
   mas[1,1] := 'a';
   mas[1,2] := 'a';
   mas[1,3] := 'b';
   mas[2,0] := 'a';
   mas[2,1] := 'a';
   mas[2,2] := 'a';
   mas[2,3] := 'c';
   ASM
      MOV CX, 0 //счетчик
      MOV BX, 0 //BH - указывает на стркоу, с которой расположены неотсортированные строки. BL - индекс максимальной строки
      MOV EAX, 0 //будет вычисляться сдвиг в массиве

      @firstcycle:
      PUSH CX   //ложим в стек что-бы не потерять счетчик цикла
      PUSH BX   //передаем аргументы по значению
      CALL @searchMAX
      PUSH BX   //передаем аргументы по значению
      CALL @moving
      POP CX    //возвращаем текущий счетчик
      INC BH    //еще одна строка была отсортирована
      INC CL
      CMP CL, N
      JBE @firstcycle
      JMP @exit

      @searchMAX: //CL - счетчик по символам в строке
      MOV BX, [ESP+4]  //получаем аргумент из стека
      MOV CH, BH // CH - счетчик по строкам. Он пропускает уже отсортированные строки
      MOV BL, BH // с самого начала считаем, что первая строка (из неотсортированных строк) максимальная
      @cycleMAX:
      MOV AL, M  //высчитываем смещение для предполагаемой максимальной строки
      INC AL
      MUL BL
      ADD AL, CL
      MOV DH, mas[EAX] //в DH хранится символ из предполагаемой максимальной строки
      MOV AL, M  //высчитываем смещение для строки, с которой будем сравнивать
      INC AL
      MUL CH
      ADD AL, CL
      MOV DL, mas[EAX] //в DL хранится символ из строки, с которой сравниваем
      CMP DH, DL  //сравниваем символы строк
      JB @nextStr   //если у пердполагаемой максимальной строки символ больше, то сравниваем со следующей строкой
      JE @nextSymbol  //если символы равны, то сравниваем по следующему символу
      MOV BL, CH    //если символ у предполагаемой макс. строки меньше, то изменяем индекс максиммальной строки
      JMP @nextStr
      @nextSymbol: //выбираем следующие символы. Проверяем что-бы не вышли за пределы
      INC CL
      CMP CL, M
      JBE @cycleMAX
      @nextStr:  //переходим на следующие строки. Проверяем на выход за пределы. Обнуляем счетчик по символам
      MOV CL, 0
      INC CH
      CMP CH, N
      JBE @cycleMAX
      RET 2  //если перебрали все строки, то возвращаемся из процедуры и сбрасываем аргумент из стека (сдвигаем ESP на 2 байта)

      @moving:     //меняем местами максимальную строку и первую строку из неотсортированных
      MOV BX, [ESP+4]  //получаем аргумент
      MOV AL, M        //вычисляем смещение для первой неотсортированной строки
      INC AL
      MUL BH
      MOVZX EDX, AX //храним смещение для первой неотсортированной строки
      MOV AL, M     //вычисляем смещение для максимальной строки
      INC AL
      MUL BL
      MOV CL, 0 //посимвольный счетчик
      @cycleMOV:
      MOVZX EDI, CL
      MOV CH, mas[EDX][EDI]     //меняем местами символы из строк (сложная адрессация)
      XCHG CH, mas[EAX][EDI]
      MOV mas[EDX][EDI], CH
      INC CL
      CMP CL, M
      JBE @cycleMOV
      RET 2

      @exit:
   END;
   for i := 0 to N do
   begin
      for j := 0 to M do
         Write(mas[i,j]);
      Writeln();
   end;
   Readln();
END.
