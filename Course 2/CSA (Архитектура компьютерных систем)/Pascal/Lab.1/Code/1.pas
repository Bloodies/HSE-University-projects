{$ASMMODE INTEL}
VAR
    num: byte;
    answ: word;
BEGIN
    WriteLn('Введите число [0..255]: ');
    Readln(num);
    answ := 0;
    ASM
       MOV AL, num   //в AL записываем введенное число
       MOV CL, 10    //в CL всегда будет запсано 10 (делить будем брять последнюю цифру числа)
       MOV ESI, ESP  //сохраняем в ESI первоначальный указатель стека, что бы узнать сколько цифр из стека доставать

       @1:
       MOV AH, 0     //обнуляем, тк в AH помещается остаток от деления
       DIV CL        //делим на 10 (в AH помещается  остаток, а в AL - частное)
       MOVZX DX, AH  //остаток переносим в DX (тк AH - 8 бит, а DX - 16 бит, поэтому используем команду MOVZX. Она заполняет недостоющие биты 0)
       PUSH DX       //помещаем остаток в стек
       CMP AL, 0     //проверяем не закончилось ли число
       JNE @1        //если число еще осталость, то повторяем цикл

       MOV BX, 0
       @2:
       SHL BX, 4     //смещаем биты на 4 влево (потом в эти освободившиеся биты будем ложить цифру)
       POP DX        //вытаскиваем из стека цифру (сначала вытаскиваются старшие цифры)
       OR BX, DX     //помещаем в 4 первых бита BX цифру
       CMP ESI, ESP  //проверяем есть ли еще цифры в стеке
       JNE @2        //если есть то повторяем цикл

       MOV answ, BX  //записываем ответ (получается запокованное двоично-десятичное число (одна цифра занимает 4 бита))
    END;

       Writeln(answ);
       Readln();
END.
